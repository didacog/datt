#!/bin/bash
#
# datt script (DRLM Automated Testing Tool)


# Define generic variables
PROGNAME=${0##*/}
VERSION=0.1

BIN_DIR="./bin"
CONF_DIR="./conf"
TESTS_DIR="./tests"
LIBS_DIR="./libs"
VAGRANT_DIR="./vagrant"

# Load datt libraries
for lib in $(ls $LIBS_DIR/*)
do
    source $lib 
done
# Load datt configurations
for cfg in default servers clients
do
    source $CONF_DIR/$cfg.conf
done

# Vagrant variables
VAGRANT_DEFAULT_PROVIDER=libvirt
VAGRANT_CWD=$VAGRANT_DIR
export VAGRANT_DEFAULT_PROVIDER VAGRANT_CWD


echo "
+-----------------------------------------------+
|         DRLM Automated Testing Tool           |
|             version $VERSION                      |
+-----------------------------------------------+
Author: Didac Oliveira
Copyright: GPL v3
"


#if [[ $(id -u) -ne 0 ]] ; then
#    Error "Please run $PRGNAME as root"
#fi


# check if vagrant is present
if ! type -p vagrant &>/dev/null ; then
    Error "Please install Vagrant 1.8.7 or higher"
fi

# hard-code the correct security settings on vagrant SSH keys
if [[ -f $VAGRANT_DIR/insecure_keys/ssh.priv ]] ; then
    chmod 600 $VAGRANT_DIR/insecure_keys/ssh.priv
    chmod 644 $VAGRANT_DIR/insecure_keys/ssh.pub
else
    Error "file $VAGRANT_DIR/insecure_keys/ssh.priv not found"
fi

# We have chosen the proper provider - did we? Check the basics - are the main paths there or not?
[[ ! -d /var/lib/libvirt ]] && Error "Libvirt seems not to be installed"


while getopts ":s:c:t:vh" opt; do
    case "$opt" in
        s) servers=( $(echo "$OPTARG" | tr ',' ' ') ) ;;
        c) clients=( $(echo "$OPTARG" | tr ',' ' ') );;
	t) tests=( $(echo "$OPTARG" | tr ',' ' ') ) ;;
        h) helpMsg; exit 0 ;;
        v) echo "$PROGNAME version $VERSION"; exit 0 ;;
       \?) echo "$PROGNAME: unknown option used: [$OPTARG]."
           helpMsg; exit 0 ;;
    esac
done
shift $(( OPTIND - 1 ))

# check servers array by distro error if wrong distro
# check clients array by distro error if wrong distro

DATT_CMD=$1
case "$DATT_CMD" in
    vagrant-up) 
        # start defined vagrant environment for testing
        ;;
    vagrant-destroy) 
        # destroy defined vagrant environment for testing
        ;;
    vagrant-suspend) 
        # suspend defined vagrant environment for testing
        ;;
    vagrant-resume) 
        # resume defined vagrant environment for testing
        ;;
    vagrant-status) 
        # show status vagrant environment for testing
        ;;
    test-prep) 
        # prepare defined tests to run in the prepared environment
        ;;
    test-list) 
        # list available tests to run in the prepared environment
        ;;
    test-run) 
        # run defined tests in the environment
        ;;
    *) echo "$PROGNAME: unknown command used: [$DATT_CMD]."
       helpMsg; exit 0 ;;
esac



# Check and/or add the client/server IP addresses to the local /etc/hosts file
grep -q "^$client" /etc/hosts
if [[ $? -eq 1 ]] ;then
   echo "Add IP addresses of client and server to /etc/hosts file (on the vagrant host)"
   echo "192.168.33.10   vagrant-client" >> /etc/hosts
   echo "192.168.33.15   vagrant-server" >> /etc/hosts
   echo "192.168.33.1    vagrant-host" >> /etc/hosts
fi

# Verify the real user's .ssh/config file
user=$(findUser)
my_home=$(getent passwd | grep ^${user} | cut -d: -f6)
[[ ! -f "$my_home/.ssh/config" ]] && touch "$my_home/.ssh/config"
grep -q "vagrant-client" "$my_home/.ssh/config" 2>/dev/null
if [[ $? -ge 1 ]] ;then
    echo "HOST vagrant-client vagrant-server" >> "$my_home/.ssh/config"
    echo "     CheckHostIP no" >> "$my_home/.ssh/config"
    echo "     StrictHostKeyChecking no" >> "$my_home/.ssh/config"
    echo "     UserKnownHostsFile /dev/null" >> "$my_home/.ssh/config"
    echo "     VerifyHostKeyDNS no" >> "$my_home/.ssh/config"
fi



# trap Cntrl-C interrupts during vagrant calls (we will foresee a small time to interrupt
# during a period that is safe - meaning do not scratch a VM box)
trap '' SIGINT

# start up and client server vagrant VMs (the recover VM stays down)
echo "$(italic Bringing up the vagrant VMs client and server)"
vagrant up
echo

trap - SIGINT       # disable the trap
echo "$(italic Sleep for 5 seconds [$(bold Control-C) is now possible])"
sleep 5
echo

echo "------------------------------------------------------------------------------"
vagrant status
echo "------------------------------------------------------------------------------"
echo

# if we are dealing with virtualbox if might be that $client/$server are not pingable due to an
# bug in vagrant itself
# Work-around is to check if "eth1" is active - if not then restart the network
echo "Check if 'eth1' is active on client $(italic [known issue https://github.com/mitchellh/vagrant/issues/8166])"
vagrant ssh client -c "sudo su -c \"ip addr show dev eth1 | grep -q DOWN && systemctl restart network.service\""

echo "Check if 'eth1' is active on server"
vagrant ssh server -c "sudo su -c \"ip addr show dev eth1 | grep -q DOWN && systemctl restart network.service\""

echo "$(bold Doing ping tests to VMs client and server)"
if IsNotPingable $client ; then
    Error "VM $client is not pingable - please investigate why"
else
    echo "$(bold client) is up and running - ping test $(green OK)"
fi


if IsNotPingable $server ; then
    Error "VM $server is not pingable - please investigate why"
else
    echo "$(bold server) is up and running - ping test $(green OK)"
fi

# first update rear inside VM client
echo
echo "$(bold Update rear on the VM client)"
ssh -i ../insecure_keys/vagrant.private root@$client "timeout 3m yum -y update rear" 2>/dev/null
echo

# Option -f test will be executed on 'client' VM only (at least for now)
# Therefore, check if the test is an existing directory for the test we want
if [[ "$DO_TEST" = "y" ]] ; then
    # $test_dir contains the test we want to execute; first copy it to the client vm
    echo "$(bold Copying the Beaker tests onto the VM client)"    
    scp -i ../insecure_keys/vagrant.private -r ../tests root@$client:/var/tmp 2>/dev/null
    # install rear-rhts and beakerlib
    echo "$(italic Install rear-rhts  and beakerlib packages required for the Beaker tests)"
    ssh -i ../insecure_keys/vagrant.private root@$client "timeout 3m yum -y install rear-rhts beakerlib"
    # on the client vm all tests are available under /var/tmp/tests/
    echo "Executing test $test_dir"
    echo "---------------------------------"
    ssh -i ../insecure_keys/vagrant.private root@$client "cd /var/tmp/tests/$test_dir ; make" 2>/dev/null
    rc=$?
    [[ $rc -gt 0 ]] && Error "make command failed for test $test_dir"
    jFile=/$(ssh -i ../insecure_keys/vagrant.private root@$client 'tail -1 /mnt/testarea/current.log | cut -d/ -f2-' 2>/dev/null)
    # jFile=/var/tmp/beakerlib-lGspW7z/journal.txt for example
    [[ "$jFile" = "/" ]] && Error "Test results file not found on $client (check /mnt/testarea)"
    scp -i ../insecure_keys/vagrant.private root@$client:$jFile ../tests/$test_dir/test-results-of-$(date '+%Y%m%d')
    echo "Saved the results as tests/$test_dir/test-results-of-$(date '+%Y%m%d')"
    exit 0
fi

# PXE/ISO boot server - for ISO boot_server should always be defined
# for PXE with virtualbox we need boot_server (the host); with libvirt we can PXE boot from the server VM
# However, with virtualbox the boot_server should be 10.0.2.2 which is not pingable from here :-//
# My advise, do not define $boot_server as argument with virtualbox
# Perhaps it is not required anymore?? Need to think about it....
#if [[ "$server" != "$boot_server" ]] ; then
#    # the hypervisor or host system must be reachable of course
#    if IsNotPingable $boot_server ; then
#        echo "System $boot_server is not pingable - please investigate why"
#        exit 1
#    else
#        echo "System $boot_server is up and running - ping test OK"
#    fi
#fi

# According the boot_method we can do different stuff now:
case $boot_method in
#~~~~~~~~~~~~~~~~~~
PXE)
####
    case $VAGRANT_DEFAULT_PROVIDER in
        virtualbox) boot_server="10.0.2.2"
                    # with VirtualBox the TFTP boot path is under:
                    pxe_tftpboot_path="/root/.config/VirtualBox/TFTP"
                    [[ ! -d "$pxe_tftpboot_path" ]] && mkdir -p -m 755 "$pxe_tftpboot_path"
                    [[ ! -d "$pxe_tftpboot_path/pxelinux.cfg" ]] && mkdir -p -m 755 "$pxe_tftpboot_path/pxelinux.cfg"
                    ;;
        #libvirt)   we use the $server to PXE boot from
    esac

    # Copy the ReaR config template to the client VM, but first we need to replace @server@ and @boot_server@ with the
    # real values defined with arguments given or use the default ones
    sed -e "s;@server@;$server;g" -e "s;@boot_server@;$boot_server;g" \
        -e "s;@pxe_tftpboot_path@;$pxe_tftpboot_path;g" < $REAR_CONFIG > /tmp/rear_config.$$
    echo "$(bold Configure rear on client to use $(green OUTPUT=PXE) method)"
    scp -i ../insecure_keys/vagrant.private /tmp/rear_config.$$ root@$client:/etc/rear/local.conf 2>/dev/null
    echo

    echo "Copy PXE post script to disable PXE booting after sucessful 'rear recover'"
    ssh -i ../insecure_keys/vagrant.private root@$client "mkdir -p -m 755 /usr/share/rear/wrapup/PXE/default" 2>/dev/null
    scp -i ../insecure_keys/vagrant.private ../rear-scripts/200_inject_default_boothd0_boot_method.sh root@$client:/usr/share/rear/wrapup/PXE/default/200_inject_default_boothd0_boot_method.sh 2>/dev/null

    ;;
#~~~~~~~~~~~~~~~~~~~~
ISO)
####
   echo "$(red WARNING: Sorry 'not' (yet completely) implemented by $PRGNAME)"
   case $VAGRANT_DEFAULT_PROVIDER in
       virtualbox) boot_server="10.0.2.2" ;;
       libvirt)    boot_server="192.168.33.1" ;;
   esac

   # We expect that the REAR_CONFIG was an argument with this script
   sed -e "s/@server@/$server/g" -e "s/@boot_server@/$boot_server/g" < $REAR_CONFIG > /tmp/rear_config.$$
   echo "$(bold Configure rear on client to use $(green OUTPUT=ISO) method)"
   scp -i ../insecure_keys/vagrant.private /tmp/rear_config.$$ root@$client:/etc/rear/local.conf 2>/dev/null
   echo

   ;;
#~~~~~~~~~~~~~~~~~~~~
*)
    Error "Boot method $boot_method 'not' yet foreseen by $PRGNAME"
    ;;
esac

# remove the temporary ReaR config file from this host
rm -f /tmp/rear_config.$$

echo
echo "$(bold ReaR version that will be tested is:)"
ssh -i ../insecure_keys/vagrant.private root@$client "rear -V" 2>/dev/null
echo

echo "$(bold Content of /etc/rear/local.conf is:)"
ssh -i ../insecure_keys/vagrant.private root@$client "grep -v \# /etc/rear/local.conf" 2>/dev/null
echo

echo "$(bold Run 'rear -v mkbackup')"
ssh -i ../insecure_keys/vagrant.private root@$client "rear -v mkbackup" 2>/dev/null
rc=$?

echo
if [[ $rc -ne 0 ]] ; then
    echo "$(red Please check the rear logging /var/log/rear/rear-client.log)"
    echo "The last 20 lines are:"
    ssh -i ../insecure_keys/vagrant.private root@$client "tail -20 /var/log/rear/rear-client.log" 2>/dev/null
    echo
    Error "Check yourself via 'vagrant ssh client'"
else
    echo "$(bold $(green The rear mkbackup was successful))"
    echo
fi

# According the boot_method we can do different stuff now:
case $boot_method in
    PXE)
    ####

    # For PXE access we have to make sure that on the server the client area is readable for others
    # In my ~/.ssh/config file I defined the line "UserKnownHostsFile /dev/null" to avoid issues
    # with duplicate host keys (after re-installing from scratch the VMs)

    echo "$(bold Make client area readable for others on PXE boot server $(green $boot_server))"
    case $VAGRANT_DEFAULT_PROVIDER in
       virtualbox) chmod 755 "$pxe_tftpboot_path"/client
                   ;;
       libvirt)    ssh -i ../insecure_keys/vagrant.private root@$boot_server "chmod 755 /export/nfs/tftpboot/client" 2>/dev/null
                   ;;
    esac
    echo
    ;;

    ISO)
    ####
    # Todo: clean up the PXE area to avoid PXE booting?
    :
    ;;

esac

echo "$(bold Halting the client VM $(italic before doing the recovery))"
echo "Recover VM will use the client IP address after it has been fully restored"
echo
vagrant halt client
echo

# For issue #15 with virtualbox and "recover: Warning: Authentication failure. Retrying" we need to copy
# the client private key to the recover directory
case $VAGRANT_DEFAULT_PROVIDER in
    virtualbox) 
        if [[ -f .vagrant/machines/client/virtualbox/private_key ]] ; then
            cp .vagrant/machines/client/virtualbox/private_key .vagrant/machines/recover/virtualbox/private_key
            echo "Copied private key of client VB to recover VB config area"
        fi
        ;;
esac

echo "$(bold Starting the recover VM)"
vagrant up recover

type -p vncviewer >/dev/null
rc=$?
if [[ $rc -ne 0 ]] ; then
    echo "To see what happens install vncviewer, or use 'vagrant ssh recover'"
    echo
else
    echo "Script will pauze until you disconnect from the 'vncviewer' application"
    echo
    vncviewer 127.0.0.1:5993 
fi

# Go back to original starting directory
cd $Current_dir

exit 0
